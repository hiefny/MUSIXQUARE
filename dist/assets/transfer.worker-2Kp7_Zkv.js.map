{"version":3,"file":"transfer.worker-2Kp7_Zkv.js","sources":["../src/workers/transfer.worker.ts"],"sourcesContent":["/**\r\n * MUSIXQUARE 2.0 — Transfer Worker (OPFS File I/O)\r\n * Ported from js/transfer.worker.js\r\n *\r\n * Handles heavy file I/O operations with session-aware locking.\r\n */\r\n\r\n'use strict';\r\n\r\n// self is already typed as DedicatedWorkerGlobalScope in WebWorker lib\r\n\r\n// ─── Types ──────────────────────────────────────────────────────\r\n\r\ninterface OpfsSlot {\r\n  handle: FileSystemFileHandle | null;\r\n  accessHandle: FileSystemSyncAccessHandle | null;\r\n  writable: FileSystemWritableFileStream | null;\r\n  mode: 'sync' | 'writable' | null;\r\n  name: string | null;\r\n  chunkSize: number;\r\n  writtenChunks: number;\r\n  sessionId: number | null;\r\n  isLocked: boolean;\r\n  lockTime: number;\r\n}\r\n\r\n// ─── Constants ──────────────────────────────────────────────────\r\n\r\nconst DEFAULT_CHUNK_SIZE = 16384;\r\nconst LOCK_TIMEOUT_MS = 60000;\r\nconst PRELOAD_LOCK_TIMEOUT_MS = 20000;\r\n\r\n// ─── State ──────────────────────────────────────────────────────\r\n\r\nfunction createOpfsSlot(): OpfsSlot {\r\n  return {\r\n    handle: null,\r\n    accessHandle: null,\r\n    writable: null,\r\n    mode: null,\r\n    name: null,\r\n    chunkSize: DEFAULT_CHUNK_SIZE,\r\n    writtenChunks: 0,\r\n    sessionId: null,\r\n    isLocked: false,\r\n    lockTime: 0,\r\n  };\r\n}\r\n\r\nconst currentFileOpfs = createOpfsSlot();\r\nconst preloadFileOpfs = createOpfsSlot();\r\nlet instanceId = 'default';\r\n\r\n// ─── Queue ──────────────────────────────────────────────────────\r\n\r\nlet isProcessing = false;\r\nconst messageQueue: (Record<string, unknown> | null)[] = [];\r\nlet queueIndex = 0;\r\n\r\nself.onmessage = (e: MessageEvent) => {\r\n  messageQueue.push(e.data);\r\n  if (!isProcessing) processQueue();\r\n};\r\n\r\nasync function processQueue(): Promise<void> {\r\n  if (isProcessing) return;\r\n  isProcessing = true;\r\n\r\n  try {\r\n    while (queueIndex < messageQueue.length) {\r\n      const data = messageQueue[queueIndex++];\r\n      try {\r\n        if (data) await handleMessage(data);\r\n      } catch (err: unknown) {\r\n        const e2 = err as Error;\r\n        console.error('[TransferWorker] Message error:', e2);\r\n        safePost({\r\n          type: 'WORKER_ERROR',\r\n          scope: 'transfer',\r\n          error: e2?.message ?? String(err),\r\n          command: data?.command,\r\n          stack: e2?.stack,\r\n        });\r\n      }\r\n      messageQueue[queueIndex - 1] = null;\r\n      if (queueIndex >= 128) {\r\n        messageQueue.splice(0, queueIndex);\r\n        queueIndex = 0;\r\n      }\r\n    }\r\n  } finally {\r\n    if (queueIndex > 0) {\r\n      messageQueue.splice(0, queueIndex);\r\n      queueIndex = 0;\r\n    }\r\n    isProcessing = false;\r\n    if (messageQueue.length > 0) processQueue();\r\n  }\r\n}\r\n\r\n// ─── Helpers ────────────────────────────────────────────────────\r\n\r\nfunction safePost(msg: Record<string, unknown>, transfers?: Transferable[]): void {\r\n  try {\r\n    if (transfers) self.postMessage(msg, transfers);\r\n    else self.postMessage(msg);\r\n  } catch (e) {\r\n    console.error('[TransferWorker] postMessage failed:', e);\r\n  }\r\n}\r\n\r\nfunction nowMs(): number { return Date.now(); }\r\n\r\nfunction isValidSessionId(sessionId: unknown): sessionId is number {\r\n  return (typeof sessionId === 'number' && Number.isInteger(sessionId));\r\n}\r\n\r\nfunction sanitizeFilename(filename: string): string {\r\n  return String(filename || '').replace(/[^a-z0-9._-]/gi, '_');\r\n}\r\n\r\nfunction buildSafeName(filename: string, isPreload: boolean): string {\r\n  return (isPreload ? 'preload_' : 'current_') + sanitizeFilename(filename) + '_' + instanceId;\r\n}\r\n\r\nfunction normalizeChunkSize(v: unknown): number {\r\n  const n = Number(v);\r\n  if (!Number.isFinite(n) || n <= 0) return DEFAULT_CHUNK_SIZE;\r\n  return Math.max(256, Math.floor(n));\r\n}\r\n\r\nfunction normalizeIndex(v: unknown): number | null {\r\n  const n = Number(v);\r\n  if (!Number.isFinite(n) || n < 0) return null;\r\n  return Math.floor(n);\r\n}\r\n\r\nfunction normalizeChunk(chunk: unknown): Uint8Array | null {\r\n  if (!chunk) return null;\r\n  if (chunk instanceof Uint8Array) return chunk;\r\n  if (chunk instanceof ArrayBuffer) return new Uint8Array(chunk);\r\n  if (ArrayBuffer.isView(chunk) && chunk.buffer) {\r\n    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);\r\n  }\r\n  return null;\r\n}\r\n\r\n// Dedupe session mismatch spam\r\nlet _lastMismatchKey: string | null = null;\r\nfunction postSessionMismatch(payload: Record<string, unknown>): void {\r\n  const key = `${payload.command}|${payload.expected}|${payload.received}|${payload.filename}|${payload.isPreload ? 'P' : 'C'}`;\r\n  if (key === _lastMismatchKey) return;\r\n  _lastMismatchKey = key;\r\n  safePost(payload);\r\n}\r\n\r\n// ─── Lock ───────────────────────────────────────────────────────\r\n\r\nasync function cleanupHandle(opfsObj: OpfsSlot, reason: string): Promise<void> {\r\n  if (opfsObj.accessHandle) {\r\n    console.log(`[TransferWorker] Closing sync handle for ${opfsObj.name} (${reason})`);\r\n    try {\r\n      if (typeof opfsObj.accessHandle.flush === 'function') await opfsObj.accessHandle.flush();\r\n      if (typeof opfsObj.accessHandle.close === 'function') await opfsObj.accessHandle.close();\r\n    } catch (e: unknown) {\r\n      console.warn('[TransferWorker] Sync handle cleanup warning:', (e as Error)?.message ?? e);\r\n    } finally {\r\n      opfsObj.accessHandle = null;\r\n    }\r\n  }\r\n  if (opfsObj.writable) {\r\n    console.log(`[TransferWorker] Closing writable stream for ${opfsObj.name} (${reason})`);\r\n    try {\r\n      if (typeof opfsObj.writable.close === 'function') await opfsObj.writable.close();\r\n    } catch {\r\n      try { if (typeof opfsObj.writable!.abort === 'function') await opfsObj.writable!.abort(); } catch { /* ignore */ }\r\n    } finally {\r\n      opfsObj.writable = null;\r\n    }\r\n  }\r\n  opfsObj.mode = null;\r\n  opfsObj.handle = null;\r\n}\r\n\r\nasync function acquireLock(opfsObj: OpfsSlot, sessionId: number, filename: string, isPreload: boolean): Promise<boolean> {\r\n  const now = nowMs();\r\n  const timeout = isPreload ? PRELOAD_LOCK_TIMEOUT_MS : LOCK_TIMEOUT_MS;\r\n\r\n  if (!isValidSessionId(sessionId)) {\r\n    console.error(`[TransferWorker] Invalid sessionId type: ${typeof sessionId} (${sessionId})`);\r\n    return false;\r\n  }\r\n\r\n  if (opfsObj.isLocked && opfsObj.name === filename) {\r\n    if (sessionId === opfsObj.sessionId) {\r\n      opfsObj.lockTime = now;\r\n      return true;\r\n    }\r\n    if (sessionId < opfsObj.sessionId!) {\r\n      console.warn(`[TransferWorker] Stale session ${sessionId} tried to renew lock held by ${opfsObj.sessionId}`);\r\n      return false;\r\n    }\r\n    await cleanupHandle(opfsObj, `Preemption by session ${sessionId} (was ${opfsObj.sessionId})`);\r\n  }\r\n\r\n  if (opfsObj.isLocked && opfsObj.name !== filename) {\r\n    const age = now - opfsObj.lockTime;\r\n    if (sessionId >= opfsObj.sessionId!) {\r\n      await cleanupHandle(opfsObj, `Preemption for new file by session ${sessionId}`);\r\n    } else if (age < timeout) {\r\n      return false;\r\n    } else {\r\n      await cleanupHandle(opfsObj, `Stale lock cleanup by session ${sessionId}`);\r\n    }\r\n  }\r\n\r\n  opfsObj.sessionId = sessionId;\r\n  opfsObj.name = filename;\r\n  opfsObj.isLocked = true;\r\n  opfsObj.lockTime = now;\r\n  return true;\r\n}\r\n\r\nasync function releaseLock(opfsObj: OpfsSlot): Promise<void> {\r\n  const oldName = opfsObj.name;\r\n  opfsObj.isLocked = false;\r\n  opfsObj.sessionId = null;\r\n  opfsObj.name = null;\r\n  opfsObj.lockTime = 0;\r\n  await cleanupHandle(opfsObj, `Manual release for ${oldName}`);\r\n  opfsObj.writtenChunks = 0;\r\n}\r\n\r\n// ─── Message Handler ────────────────────────────────────────────\r\n\r\nasync function handleMessage(data: Record<string, unknown>): Promise<void> {\r\n  const command = data.command as string | undefined;\r\n\r\n  if (command === 'INIT_INSTANCE') {\r\n    instanceId = (data.instanceId as string) || 'default';\r\n    _lastMismatchKey = null;\r\n    console.log(`[TransferWorker] Instance Initialized: ${instanceId}`);\r\n    return;\r\n  }\r\n\r\n  if (command === 'OPFS_START') {\r\n    const filename = data.filename as string;\r\n    const isPreload = !!data.isPreload;\r\n    const sessionId = data.sessionId as number;\r\n    const opfsObj = isPreload ? preloadFileOpfs : currentFileOpfs;\r\n\r\n    if (!filename) {\r\n      safePost({ type: 'OPFS_ERROR', error: 'Missing filename', filename, isPreload, code: 'BAD_ARGS' });\r\n      return;\r\n    }\r\n\r\n    if (!(await acquireLock(opfsObj, sessionId, filename, isPreload))) {\r\n      safePost({ type: 'OPFS_ERROR', error: 'Lock Collision', filename, isPreload, code: 'LOCKED' });\r\n      return;\r\n    }\r\n\r\n    opfsObj.chunkSize = normalizeChunkSize(data.size);\r\n    opfsObj.writtenChunks = 0;\r\n\r\n    try {\r\n      await cleanupHandle(opfsObj, 'New start');\r\n      const root = await navigator.storage.getDirectory();\r\n      const safeName = buildSafeName(filename, isPreload);\r\n\r\n      if (!data.keepExisting) {\r\n        try { await root.removeEntry(safeName); } catch { /* file may not exist */ }\r\n      }\r\n\r\n      opfsObj.handle = await root.getFileHandle(safeName, { create: true });\r\n\r\n      let opened = false;\r\n      if (opfsObj.handle && typeof (opfsObj.handle as unknown as Record<string, unknown>).createSyncAccessHandle === 'function') {\r\n        try {\r\n          opfsObj.accessHandle = await (opfsObj.handle as unknown as { createSyncAccessHandle(): Promise<FileSystemSyncAccessHandle> }).createSyncAccessHandle();\r\n          opfsObj.mode = 'sync';\r\n          opened = true;\r\n        } catch (e: unknown) {\r\n          console.warn('[TransferWorker] createSyncAccessHandle failed, falling back:', (e as Error)?.message ?? e);\r\n        }\r\n      }\r\n\r\n      if (!opened) {\r\n        if (opfsObj.handle && typeof opfsObj.handle.createWritable === 'function') {\r\n          opfsObj.writable = await opfsObj.handle.createWritable({ keepExistingData: !!data.keepExisting });\r\n          opfsObj.mode = 'writable';\r\n          opened = true;\r\n        }\r\n      }\r\n\r\n      if (!opened) throw new Error('No supported OPFS write interface');\r\n\r\n      safePost({ type: 'OPFS_STARTED', filename, isPreload, sessionId });\r\n    } catch (e: unknown) {\r\n      await releaseLock(opfsObj);\r\n      safePost({ type: 'OPFS_ERROR', error: (e as Error)?.message ?? String(e), filename, isPreload, code: 'START_FAILED' });\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (command === 'OPFS_WRITE') {\r\n    const filename = data.filename as string;\r\n    const isPreload = !!data.isPreload;\r\n    const sessionId = data.sessionId as number;\r\n    const opfsObj = isPreload ? preloadFileOpfs : currentFileOpfs;\r\n\r\n    if (sessionId !== opfsObj.sessionId) {\r\n      postSessionMismatch({\r\n        type: 'SESSION_MISMATCH', command: 'OPFS_WRITE',\r\n        expected: opfsObj.sessionId, received: sessionId, filename, isPreload,\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (!filename || opfsObj.name !== filename) return;\r\n\r\n    const index = normalizeIndex(data.index);\r\n    if (index === null) {\r\n      safePost({ type: 'OPFS_WRITE_ERROR', error: 'Invalid index', filename, chunk: data.index, isPreload });\r\n      return;\r\n    }\r\n\r\n    const chunk = normalizeChunk(data.chunk);\r\n    if (!chunk) {\r\n      safePost({ type: 'OPFS_WRITE_ERROR', error: 'Invalid chunk', filename, chunk: index, isPreload });\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const offset = index * opfsObj.chunkSize;\r\n      if (opfsObj.mode === 'sync' && opfsObj.accessHandle) {\r\n        opfsObj.accessHandle.write(chunk, { at: offset });\r\n        opfsObj.writtenChunks++;\r\n        opfsObj.lockTime = nowMs();\r\n        if (opfsObj.writtenChunks % 100 === 0 && typeof opfsObj.accessHandle.flush === 'function') {\r\n          await opfsObj.accessHandle.flush();\r\n        }\r\n      } else if (opfsObj.mode === 'writable' && opfsObj.writable) {\r\n        await opfsObj.writable.write({ type: 'write', position: offset, data: chunk as unknown as BufferSource });\r\n        opfsObj.writtenChunks++;\r\n        opfsObj.lockTime = nowMs();\r\n      }\r\n    } catch (e: unknown) {\r\n      safePost({ type: 'OPFS_WRITE_ERROR', error: (e as Error)?.message ?? String(e), filename, chunk: index, isPreload });\r\n      try { await releaseLock(opfsObj); } catch { /* ignore */ }\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (command === 'OPFS_END') {\r\n    const filename = data.filename as string;\r\n    const isPreload = !!data.isPreload;\r\n    const sessionId = data.sessionId as number;\r\n    const totalSize = data.totalSize as number | undefined;\r\n    const opfsObj = isPreload ? preloadFileOpfs : currentFileOpfs;\r\n\r\n    if (sessionId !== opfsObj.sessionId) {\r\n      if (opfsObj.sessionId !== null) {\r\n        postSessionMismatch({\r\n          type: 'SESSION_MISMATCH', command: 'OPFS_END',\r\n          expected: opfsObj.sessionId, received: sessionId, filename, isPreload,\r\n        });\r\n      }\r\n      return;\r\n    }\r\n\r\n    try {\r\n      if (opfsObj.mode === 'sync' && opfsObj.accessHandle) {\r\n        if (typeof opfsObj.accessHandle.flush === 'function') await opfsObj.accessHandle.flush();\r\n        if (totalSize) {\r\n          const actualSize = await opfsObj.accessHandle.getSize();\r\n          if (actualSize !== totalSize) {\r\n            if (actualSize > totalSize && typeof opfsObj.accessHandle.truncate === 'function') {\r\n              try {\r\n                await opfsObj.accessHandle.truncate(totalSize);\r\n                const resized = await opfsObj.accessHandle.getSize();\r\n                if (resized !== totalSize) throw new Error(`Integrity Fail: ${resized}/${totalSize}`);\r\n              } catch { throw new Error(`Integrity Fail: ${actualSize}/${totalSize}`); }\r\n            } else {\r\n              throw new Error(`Integrity Fail: ${actualSize}/${totalSize}`);\r\n            }\r\n          }\r\n        }\r\n      } else if (opfsObj.mode === 'writable' && opfsObj.writable) {\r\n        await opfsObj.writable.close();\r\n        opfsObj.writable = null;\r\n        if (totalSize && opfsObj.handle) {\r\n          const f = await opfsObj.handle.getFile();\r\n          if (f.size !== totalSize) {\r\n            if (f.size > totalSize) {\r\n              const w = await opfsObj.handle.createWritable({ keepExistingData: true });\r\n              await w.write({ type: 'truncate', size: totalSize });\r\n              await w.close();\r\n              const f2 = await opfsObj.handle.getFile();\r\n              if (f2.size !== totalSize) throw new Error(`Integrity Fail: ${f2.size}/${totalSize}`);\r\n            } else {\r\n              throw new Error(`Integrity Fail: ${f.size}/${totalSize}`);\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        throw new Error('No open handle for OPFS_END');\r\n      }\r\n\r\n      const sidSnapshot = opfsObj.sessionId;\r\n      await releaseLock(opfsObj);\r\n      safePost({ type: 'OPFS_FILE_READY', filename, isPreload, sessionId: sidSnapshot });\r\n    } catch (e: unknown) {\r\n      await releaseLock(opfsObj);\r\n      safePost({ type: 'OPFS_ERROR', error: (e as Error)?.message ?? String(e), filename, isPreload, code: 'INTEGRITY_FAIL' });\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (command === 'OPFS_RESET') {\r\n    const isPreload = !!data.isPreload;\r\n    await releaseLock(isPreload ? preloadFileOpfs : currentFileOpfs);\r\n    safePost({ type: 'OPFS_RESET_COMPLETE', isPreload });\r\n    return;\r\n  }\r\n\r\n  if (command === 'OPFS_CLEANUP') {\r\n    const filename = data.filename as string;\r\n    const isPreload = !!data.isPreload;\r\n    const opfsObj = isPreload ? preloadFileOpfs : currentFileOpfs;\r\n\r\n    if (!filename) {\r\n      safePost({ type: 'OPFS_CLEANUP_COMPLETE', filename, isPreload });\r\n      return;\r\n    }\r\n\r\n    if (opfsObj.isLocked && opfsObj.name === filename) {\r\n      safePost({ type: 'OPFS_CLEANUP_COMPLETE', filename, isPreload, skipped: true });\r\n      return;\r\n    }\r\n\r\n    const safeName = buildSafeName(filename, isPreload);\r\n    try {\r\n      const root = await navigator.storage.getDirectory();\r\n      await root.removeEntry(safeName);\r\n    } catch { /* file may not exist */ }\r\n    safePost({ type: 'OPFS_CLEANUP_COMPLETE', filename, isPreload });\r\n    return;\r\n  }\r\n\r\n  if (command === 'OPFS_READ') {\r\n    const filename = data.filename as string;\r\n    const isPreload = !!data.isPreload;\r\n    const sessionId = data.sessionId as number | undefined;\r\n    const requestId = data.requestId;\r\n\r\n    const index = normalizeIndex(data.index);\r\n    if (!filename || index === null) {\r\n      safePost({ type: 'OPFS_READ_ERROR', error: 'BAD_ARGS', filename, index: data.index, requestId });\r\n      return;\r\n    }\r\n\r\n    const safeName = buildSafeName(filename, isPreload);\r\n\r\n    try {\r\n      const activeOpfs = isPreload ? preloadFileOpfs : currentFileOpfs;\r\n      const chunkSize = activeOpfs.chunkSize || DEFAULT_CHUNK_SIZE;\r\n      const offset = index * chunkSize;\r\n\r\n      // Preferred: reuse existing SyncAccessHandle\r\n      if (activeOpfs.isLocked && activeOpfs.name === filename && activeOpfs.mode === 'sync' && activeOpfs.accessHandle) {\r\n        const buffer = new Uint8Array(chunkSize);\r\n        const bytesRead = activeOpfs.accessHandle.read(buffer, { at: offset });\r\n        const chunk = (bytesRead === chunkSize) ? buffer : buffer.slice(0, bytesRead);\r\n        safePost({ type: 'OPFS_READ_COMPLETE', chunk, index, filename, requestId, sessionId }, [chunk.buffer]);\r\n        return;\r\n      }\r\n\r\n      // Otherwise open fresh handle\r\n      const root = await navigator.storage.getDirectory();\r\n      const fileHandle = await root.getFileHandle(safeName);\r\n\r\n      if (fileHandle && typeof (fileHandle as unknown as Record<string, unknown>).createSyncAccessHandle === 'function') {\r\n        let ah: FileSystemSyncAccessHandle | null = null;\r\n        try {\r\n          ah = await (fileHandle as unknown as { createSyncAccessHandle(): Promise<FileSystemSyncAccessHandle> }).createSyncAccessHandle();\r\n        } catch (lockErr: unknown) {\r\n          console.warn('[TransferWorker] SyncAccessHandle unavailable for read, using File fallback:', (lockErr as Error)?.message);\r\n        }\r\n        if (ah) {\r\n          try {\r\n            const buffer = new Uint8Array(chunkSize);\r\n            const bytesRead = ah.read(buffer, { at: offset });\r\n            const chunk = (bytesRead === chunkSize) ? buffer : buffer.slice(0, bytesRead);\r\n            safePost({ type: 'OPFS_READ_COMPLETE', chunk, index, filename, requestId, sessionId }, [chunk.buffer]);\r\n          } finally {\r\n            try { await ah.close(); } catch { /* ignore */ }\r\n          }\r\n          return;\r\n        }\r\n      }\r\n\r\n      // Fallback: async File slicing\r\n      const file = await fileHandle.getFile();\r\n      const slice = file.slice(offset, offset + chunkSize);\r\n      const buf = await slice.arrayBuffer();\r\n      const chunk = new Uint8Array(buf);\r\n      safePost({ type: 'OPFS_READ_COMPLETE', chunk, index, filename, requestId, sessionId }, [chunk.buffer]);\r\n    } catch (e: unknown) {\r\n      safePost({ type: 'OPFS_READ_ERROR', error: (e as Error)?.message ?? String(e), filename, index, requestId });\r\n    }\r\n  }\r\n}\r\n\r\n// ─── Global Safety ──────────────────────────────────────────────\r\n\r\nself.addEventListener('error', (e) => {\r\n  safePost({\r\n    type: 'WORKER_ERROR', scope: 'transfer', command: 'WORKER_ERROR',\r\n    error: e?.message ?? 'Worker error',\r\n  });\r\n});\r\n\r\nself.addEventListener('unhandledrejection', (e) => {\r\n  const reason = e?.reason as Error | undefined;\r\n  safePost({\r\n    type: 'WORKER_ERROR', scope: 'transfer', command: 'UNHANDLED_REJECTION',\r\n    error: reason?.message ?? String(reason),\r\n  });\r\n});\r\n\r\nself.addEventListener('messageerror', () => {\r\n  safePost({\r\n    type: 'WORKER_ERROR', scope: 'transfer', command: 'MESSAGE_ERROR',\r\n    error: 'Message deserialization failed',\r\n  });\r\n});\r\n"],"names":["createOpfsSlot","currentFileOpfs","preloadFileOpfs","instanceId","isProcessing","messageQueue","queueIndex","processQueue","data","handleMessage","err","e2","safePost","msg","transfers","e","nowMs","isValidSessionId","sessionId","sanitizeFilename","filename","buildSafeName","isPreload","normalizeChunkSize","v","n","normalizeIndex","normalizeChunk","chunk","_lastMismatchKey","postSessionMismatch","payload","key","cleanupHandle","opfsObj","reason","acquireLock","now","timeout","age","releaseLock","oldName","command","root","safeName","opened","index","offset","totalSize","actualSize","resized","f","w","f2","sidSnapshot","requestId","activeOpfs","chunkSize","buffer","bytesRead","fileHandle","ah","lockErr","buf"],"mappings":"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"}