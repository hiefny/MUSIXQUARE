function H(){return{handle:null,accessHandle:null,writable:null,mode:null,name:null,chunkSize:16384,writtenChunks:0,sessionId:null,isLocked:!1,lockTime:0}}const m=H(),S=H();let k="default",P=!1;const E=[];let u=0;self.onmessage=e=>{E.push(e.data),P||C()};async function C(){if(!P){P=!0;try{for(;u<E.length;){const e=E[u++];try{e&&await U(e)}catch(r){const t=r;console.error("[TransferWorker] Message error:",t),c({type:"WORKER_ERROR",scope:"transfer",error:t?.message??String(r),command:e?.command,stack:t?.stack})}E[u-1]=null,u>=128&&(E.splice(0,u),u=0)}}finally{u>0&&(E.splice(0,u),u=0),P=!1,E.length>0&&C()}}}function c(e,r){try{r?self.postMessage(e,r):self.postMessage(e)}catch(t){console.error("[TransferWorker] postMessage failed:",t)}}function T(){return Date.now()}function N(e){return typeof e=="number"&&Number.isInteger(e)}function D(e){return String(e||"").replace(/[^a-z0-9._-]/gi,"_")}function I(e,r){return(r?"preload_":"current_")+D(e)+"_"+k}function $(e){const r=Number(e);return!Number.isFinite(r)||r<=0?16384:Math.max(256,Math.floor(r))}function O(e){const r=Number(e);return!Number.isFinite(r)||r<0?null:Math.floor(r)}function z(e){return e?e instanceof Uint8Array?e:e instanceof ArrayBuffer?new Uint8Array(e):ArrayBuffer.isView(e)&&e.buffer?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):null:null}let F=null;function p(e){const r=`${e.command}|${e.expected}|${e.received}|${e.filename}|${e.isPreload?"P":"C"}`;r!==F&&(F=r,c(e))}async function h(e,r){if(e.accessHandle){console.log(`[TransferWorker] Closing sync handle for ${e.name} (${r})`);try{typeof e.accessHandle.flush=="function"&&await e.accessHandle.flush(),typeof e.accessHandle.close=="function"&&await e.accessHandle.close()}catch(t){console.warn("[TransferWorker] Sync handle cleanup warning:",t?.message??t)}finally{e.accessHandle=null}}if(e.writable){console.log(`[TransferWorker] Closing writable stream for ${e.name} (${r})`);try{typeof e.writable.close=="function"&&await e.writable.close()}catch{try{typeof e.writable.abort=="function"&&await e.writable.abort()}catch{}}finally{e.writable=null}}e.mode=null,e.handle=null}async function W(e,r,t,s){const o=T(),n=s?2e4:6e4;if(!N(r))return console.error(`[TransferWorker] Invalid sessionId type: ${typeof r} (${r})`),!1;if(e.isLocked&&e.name===t){if(r===e.sessionId)return e.lockTime=o,!0;if(r<e.sessionId)return console.warn(`[TransferWorker] Stale session ${r} tried to renew lock held by ${e.sessionId}`),!1;await h(e,`Preemption by session ${r} (was ${e.sessionId})`)}if(e.isLocked&&e.name!==t){const i=o-e.lockTime;if(r>=e.sessionId)await h(e,`Preemption for new file by session ${r}`);else{if(i<n)return!1;await h(e,`Stale lock cleanup by session ${r}`)}}return e.sessionId=r,e.name=t,e.isLocked=!0,e.lockTime=o,!0}async function _(e){const r=e.name;e.isLocked=!1,e.sessionId=null,e.name=null,e.lockTime=0,await h(e,`Manual release for ${r}`),e.writtenChunks=0}async function U(e){const r=e.command;if(r==="INIT_INSTANCE"){k=e.instanceId||"default",F=null,console.log(`[TransferWorker] Instance Initialized: ${k}`);return}if(r==="OPFS_START"){const t=e.filename,s=!!e.isPreload,o=e.sessionId,n=s?S:m;if(!t){c({type:"OPFS_ERROR",error:"Missing filename",filename:t,isPreload:s,code:"BAD_ARGS"});return}if(!await W(n,o,t,s)){c({type:"OPFS_ERROR",error:"Lock Collision",filename:t,isPreload:s,code:"LOCKED"});return}n.chunkSize=$(e.size),n.writtenChunks=0;try{await h(n,"New start");const i=await navigator.storage.getDirectory(),f=I(t,s);if(!e.keepExisting)try{await i.removeEntry(f)}catch{}n.handle=await i.getFileHandle(f,{create:!0});let a=!1;if(n.handle&&typeof n.handle.createSyncAccessHandle=="function")try{n.accessHandle=await n.handle.createSyncAccessHandle(),n.mode="sync",a=!0}catch(l){console.warn("[TransferWorker] createSyncAccessHandle failed, falling back:",l?.message??l)}if(a||n.handle&&typeof n.handle.createWritable=="function"&&(n.writable=await n.handle.createWritable({keepExistingData:!!e.keepExisting}),n.mode="writable",a=!0),!a)throw new Error("No supported OPFS write interface");c({type:"OPFS_STARTED",filename:t,isPreload:s,sessionId:o})}catch(i){await _(n),c({type:"OPFS_ERROR",error:i?.message??String(i),filename:t,isPreload:s,code:"START_FAILED"})}return}if(r==="OPFS_WRITE"){const t=e.filename,s=!!e.isPreload,o=e.sessionId,n=s?S:m;if(o!==n.sessionId){p({type:"SESSION_MISMATCH",command:"OPFS_WRITE",expected:n.sessionId,received:o,filename:t,isPreload:s});return}if(!t||n.name!==t)return;const i=O(e.index);if(i===null){c({type:"OPFS_WRITE_ERROR",error:"Invalid index",filename:t,chunk:e.index,isPreload:s});return}const f=z(e.chunk);if(!f){c({type:"OPFS_WRITE_ERROR",error:"Invalid chunk",filename:t,chunk:i,isPreload:s});return}try{const a=i*n.chunkSize;n.mode==="sync"&&n.accessHandle?(n.accessHandle.write(f,{at:a}),n.writtenChunks++,n.lockTime=T(),n.writtenChunks%100===0&&typeof n.accessHandle.flush=="function"&&await n.accessHandle.flush()):n.mode==="writable"&&n.writable&&(await n.writable.write({type:"write",position:a,data:f}),n.writtenChunks++,n.lockTime=T())}catch(a){c({type:"OPFS_WRITE_ERROR",error:a?.message??String(a),filename:t,chunk:i,isPreload:s});try{await _(n)}catch{}}return}if(r==="OPFS_END"){const t=e.filename,s=!!e.isPreload,o=e.sessionId,n=e.totalSize,i=s?S:m;if(o!==i.sessionId){i.sessionId!==null&&p({type:"SESSION_MISMATCH",command:"OPFS_END",expected:i.sessionId,received:o,filename:t,isPreload:s});return}try{if(i.mode==="sync"&&i.accessHandle){if(typeof i.accessHandle.flush=="function"&&await i.accessHandle.flush(),n){const a=await i.accessHandle.getSize();if(a!==n)if(a>n&&typeof i.accessHandle.truncate=="function")try{await i.accessHandle.truncate(n);const l=await i.accessHandle.getSize();if(l!==n)throw new Error(`Integrity Fail: ${l}/${n}`)}catch{throw new Error(`Integrity Fail: ${a}/${n}`)}else throw new Error(`Integrity Fail: ${a}/${n}`)}}else if(i.mode==="writable"&&i.writable){if(await i.writable.close(),i.writable=null,n&&i.handle){const a=await i.handle.getFile();if(a.size!==n)if(a.size>n){const l=await i.handle.createWritable({keepExistingData:!0});await l.write({type:"truncate",size:n}),await l.close();const y=await i.handle.getFile();if(y.size!==n)throw new Error(`Integrity Fail: ${y.size}/${n}`)}else throw new Error(`Integrity Fail: ${a.size}/${n}`)}}else throw new Error("No open handle for OPFS_END");const f=i.sessionId;await _(i),c({type:"OPFS_FILE_READY",filename:t,isPreload:s,sessionId:f})}catch(f){await _(i),c({type:"OPFS_ERROR",error:f?.message??String(f),filename:t,isPreload:s,code:"INTEGRITY_FAIL"})}return}if(r==="OPFS_RESET"){const t=!!e.isPreload;await _(t?S:m),c({type:"OPFS_RESET_COMPLETE",isPreload:t});return}if(r==="OPFS_CLEANUP"){const t=e.filename,s=!!e.isPreload,o=s?S:m;if(!t){c({type:"OPFS_CLEANUP_COMPLETE",filename:t,isPreload:s});return}if(o.isLocked&&o.name===t){c({type:"OPFS_CLEANUP_COMPLETE",filename:t,isPreload:s,skipped:!0});return}const n=I(t,s);try{await(await navigator.storage.getDirectory()).removeEntry(n)}catch{}c({type:"OPFS_CLEANUP_COMPLETE",filename:t,isPreload:s});return}if(r==="OPFS_READ"){const t=e.filename,s=!!e.isPreload,o=e.sessionId,n=e.requestId,i=O(e.index);if(!t||i===null){c({type:"OPFS_READ_ERROR",error:"BAD_ARGS",filename:t,index:e.index,requestId:n});return}const f=I(t,s);try{const a=s?S:m,l=a.chunkSize||16384,y=i*l;if(a.isLocked&&a.name===t&&a.mode==="sync"&&a.accessHandle){const d=new Uint8Array(l),w=a.accessHandle.read(d,{at:y}),R=w===l?d:d.slice(0,w);c({type:"OPFS_READ_COMPLETE",chunk:R,index:i,filename:t,requestId:n,sessionId:o},[R.buffer]);return}const g=await(await navigator.storage.getDirectory()).getFileHandle(f);if(g&&typeof g.createSyncAccessHandle=="function"){let d=null;try{d=await g.createSyncAccessHandle()}catch(w){console.warn("[TransferWorker] SyncAccessHandle unavailable for read, using File fallback:",w?.message)}if(d){try{const w=new Uint8Array(l),R=d.read(w,{at:y}),L=R===l?w:w.slice(0,R);c({type:"OPFS_READ_COMPLETE",chunk:L,index:i,filename:t,requestId:n,sessionId:o},[L.buffer])}finally{try{await d.close()}catch{}}return}}const M=await(await g.getFile()).slice(y,y+l).arrayBuffer(),A=new Uint8Array(M);c({type:"OPFS_READ_COMPLETE",chunk:A,index:i,filename:t,requestId:n,sessionId:o},[A.buffer])}catch(a){c({type:"OPFS_READ_ERROR",error:a?.message??String(a),filename:t,index:i,requestId:n})}}}self.addEventListener("error",e=>{c({type:"WORKER_ERROR",scope:"transfer",command:"WORKER_ERROR",error:e?.message??"Worker error"})});self.addEventListener("unhandledrejection",e=>{const r=e?.reason;c({type:"WORKER_ERROR",scope:"transfer",command:"UNHANDLED_REJECTION",error:r?.message??String(r)})});self.addEventListener("messageerror",()=>{c({type:"WORKER_ERROR",scope:"transfer",command:"MESSAGE_ERROR",error:"Message deserialization failed"})});
//# sourceMappingURL=transfer.worker-2Kp7_Zkv.js.map
